package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"time"

	"github.com/lambda/apps/subgraph-intervention/graph/generated"
	"github.com/lambda/apps/subgraph-intervention/graph/model"
	"github.com/lambda/internal/domain"
	"github.com/lambda/internal/service"
)

// CreateInterventions is the resolver for the createInterventions field.
func (r *mutationResolver) CreateInterventions(ctx context.Context, input model.CreateInterventionsInput) (*model.CreateInterventionsResponse, error) {
	// Get tenantID and userID from context (should be set by middleware)
	tenantID := "test-tenant" // TODO: get from context
	userID := "test-user"     // TODO: get from context

	// Convert GraphQL input to service request
	req := &service.CreateInterventionsRequest{
		PatientID:    input.PatientID,
		ScreeningID:  input.ScreeningID,
		Items:        make([]service.InterventionItem, len(input.Items)),
		NotifyPeople: input.NotifyPeople,
		CreatedFrom:  input.CreatedFrom,
	}

	for i, item := range input.Items {
		var dueAt *time.Time
		if item.DueInDay != nil {
			parsed, err := time.Parse(time.RFC3339, *item.DueInDay)
			if err == nil {
				dueAt = &parsed
			}
		}

		var scheduleAt *time.Time
		if item.ScheduleInDay != nil {
			parsed, err := time.Parse(time.RFC3339, *item.ScheduleInDay)
			if err == nil {
				scheduleAt = &parsed
			}
		}

		req.Items[i] = service.InterventionItem{
			Type:            domain.InterventionType(item.Type),
			Title:           item.Title,
			ScheduleInDay:   scheduleAt,
			DueInDay:        dueAt,
			ReferralReasons: item.ReferralReasons,
			Problems:        item.Problems,
			AssignedTo:      item.AssignedTo,
			AssignedTeam:    item.AssignedTeam,
			Priority:        item.Priority,
			Description:     item.Description,
		}
	}

	resp, err := r.InterventionService.CreateInterventions(ctx, tenantID, userID, req)
	if err != nil {
		return nil, err
	}

	// Convert service response to GraphQL response
	result := &model.CreateInterventionsResponse{
		InterventionIds: resp.InterventionIDs,
		CreatedTasks:    make([]*model.CreatedTask, len(resp.CreatedTasks)),
	}

	for i, task := range resp.CreatedTasks {
		result.CreatedTasks[i] = &model.CreatedTask{
			TaskID:       task.TaskID,
			AssigneeRole: task.AssigneeRole,
		}
	}

	return result, nil
}

// UpdateIntervention is the resolver for the updateIntervention field.
func (r *mutationResolver) UpdateIntervention(ctx context.Context, id string, updates model.UpdateInterventionInput) (*model.MessageResponse, error) {
	tenantID := "test-tenant" // TODO: get from context

	updatesMap := make(map[string]interface{})
	if updates.AssignedTo != nil {
		updatesMap["assigned_to"] = *updates.AssignedTo
	}
	if updates.AssignedTeam != nil {
		updatesMap["assigned_team"] = *updates.AssignedTeam
	}
	if updates.Priority != nil {
		updatesMap["priority"] = *updates.Priority
	}
	if updates.Notes != nil {
		updatesMap["notes"] = *updates.Notes
	}
	if updates.Problems != nil {
		updatesMap["problems"] = updates.Problems
	}

	err := r.InterventionService.UpdateIntervention(ctx, tenantID, id, updatesMap)
	if err != nil {
		return nil, err
	}

	msg := "Intervention updated successfully"
	return &model.MessageResponse{Message: msg}, nil
}

// CompleteIntervention is the resolver for the completeIntervention field.
func (r *mutationResolver) CompleteIntervention(ctx context.Context, id string, notes *string) (*model.MessageResponse, error) {
	tenantID := "test-tenant" // TODO: get from context

	notesStr := ""
	if notes != nil {
		notesStr = *notes
	}

	err := r.InterventionService.CompleteIntervention(ctx, tenantID, id, notesStr)
	if err != nil {
		return nil, err
	}

	msg := "Intervention completed successfully"
	return &model.MessageResponse{Message: msg}, nil
}

// CancelIntervention is the resolver for the cancelIntervention field.
func (r *mutationResolver) CancelIntervention(ctx context.Context, id string, reason *string) (*model.MessageResponse, error) {
	tenantID := "test-tenant" // TODO: get from context

	reasonStr := ""
	if reason != nil {
		reasonStr = *reason
	}

	err := r.InterventionService.CancelIntervention(ctx, tenantID, id, reasonStr)
	if err != nil {
		return nil, err
	}

	msg := "Intervention cancelled successfully"
	return &model.MessageResponse{Message: msg}, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*string, error) {
	status := "ok"
	return &status, nil
}

// Intervention is the resolver for the intervention field.
func (r *queryResolver) Intervention(ctx context.Context, id string) (*model.Intervention, error) {
	tenantID := "test-tenant" // TODO: get from context

	intervention, err := r.InterventionService.GetInterventionByID(ctx, tenantID, id)
	if err != nil {
		return nil, err
	}

	return convertInterventionToModel(intervention), nil
}

// Interventions is the resolver for the interventions field.
func (r *queryResolver) Interventions(ctx context.Context, filters *model.InterventionFilters) (*model.InterventionList, error) {
	tenantID := "test-tenant" // TODO: get from context

	filtersMap := make(map[string]interface{})
	if filters != nil {
		if filters.Status != nil {
			filtersMap["status"] = *filters.Status
		}
		if filters.Type != nil {
			filtersMap["type"] = *filters.Type
		}
		if filters.AssignedTeam != nil {
			filtersMap["assigned_team"] = *filters.AssignedTeam
		}
		if filters.PatientID != nil {
			filtersMap["patient_id"] = *filters.PatientID
		}
		if filters.ScreeningID != nil {
			filtersMap["screening_id"] = *filters.ScreeningID
		}
		if filters.ScreeningIds != nil {
			filtersMap["screening_ids"] = filters.ScreeningIds
		}
		if filters.CreatedBy != nil {
			filtersMap["created_by"] = *filters.CreatedBy
		}
		if filters.CreatedByIds != nil {
			filtersMap["created_by_ids"] = filters.CreatedByIds
		}
	}

	interventions, err := r.InterventionService.ListInterventions(ctx, tenantID, filtersMap)
	if err != nil {
		return nil, err
	}

	result := &model.InterventionList{
		Interventions: make([]*model.Intervention, len(interventions)),
		Total:         len(interventions),
	}

	for i, intervention := range interventions {
		result.Interventions[i] = convertInterventionToModel(intervention)
	}

	return result, nil
}

// BarrierCounts is the resolver for the barrierCounts field.
func (r *queryResolver) BarrierCounts(ctx context.Context, filters *model.BarrierFilters) (*model.BarrierResponse, error) {
	tenantID := "test-tenant" // TODO: get from context

	filtersMap := make(map[string]interface{})
	if filters != nil {
		if filters.Year != nil {
			filtersMap["year"] = *filters.Year
		}
		if filters.Disease != nil {
			filtersMap["disease"] = *filters.Disease
		}
		if filters.Type != nil {
			filtersMap["type"] = *filters.Type
		}
		if filters.Month != nil {
			filtersMap["month"] = *filters.Month
		}
		if filters.CreatedBy != nil {
			filtersMap["created_by"] = *filters.CreatedBy
		}
		if filters.CreatedByIds != nil {
			filtersMap["created_by_ids"] = filters.CreatedByIds
		}
	}

	barriers, err := r.InterventionService.GetBarrierCounts(ctx, tenantID, filtersMap)
	if err != nil {
		return nil, err
	}

	result := &model.BarrierResponse{
		ChartData:   make([]*model.BarrierCount, len(barriers.ChartData)),
		SubtypeData: make([]*model.BarrierSubtype, len(barriers.SubtypeData)),
	}

	for i, bc := range barriers.ChartData {
		result.ChartData[i] = &model.BarrierCount{
			Month:        bc.Month,
			ProblemName:  bc.ProblemName,
			BarrierCount: bc.BarrierCount,
		}
	}

	for i, bs := range barriers.SubtypeData {
		result.SubtypeData[i] = &model.BarrierSubtype{
			SubType:      bs.SubType,
			BarrierCount: bs.BarrierCount,
		}
	}

	return result, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// Helper function to convert domain.Intervention to model.Intervention
func convertInterventionToModel(i *domain.Intervention) *model.Intervention {
	var user *model.User
	if i.User != nil {
		user = &model.User{
			ID:        i.User.ID.String(),
			TenantID:  i.User.TenantID.String(),
			Email:     i.User.Email,
			Username:  i.User.Username,
			Role:      string(i.User.Role),
			CreatedAt: i.User.CreatedAt.Format(time.RFC3339),
			UpdatedAt: i.User.UpdatedAt.Format(time.RFC3339),
		}
	}

	var description, assignedTo, assignedTeam, linkedTaskID, notes *string
	if i.Description != nil {
		description = i.Description
	}
	if i.AssignedTo != nil {
		assignedTo = i.AssignedTo
	}
	if i.AssignedTeam != nil {
		assignedTeam = i.AssignedTeam
	}
	if i.LinkedTaskID != nil {
		linkedTaskID = i.LinkedTaskID
	}
	if i.Notes != nil {
		notes = i.Notes
	}

	var dueAt, completedAt *string
	if i.DueAt != nil {
		formatted := i.DueAt.Format(time.RFC3339)
		dueAt = &formatted
	}
	if i.CompletedAt != nil {
		formatted := i.CompletedAt.Format(time.RFC3339)
		completedAt = &formatted
	}

	return &model.Intervention{
		ID:              i.ID,
		TenantID:        i.TenantID,
		PatientID:       i.PatientID,
		ScreeningID:     i.ScreeningID,
		Type:            model.InterventionType(i.Type),
		Title:           i.Title,
		Description:     description,
		Status:          model.InterventionStatus(i.Status),
		Priority:        i.Priority,
		CreatedBy:       i.CreatedBy,
		AssignedTo:      assignedTo,
		AssignedTeam:    assignedTeam,
		DueAt:           dueAt,
		CompletedAt:     completedAt,
		LinkedTaskID:    linkedTaskID,
		ReferralReasons: i.ReferralReasons,
		Problems:        i.Problems,
		Notes:           notes,
		CreatedAt:       i.CreatedAt.Format(time.RFC3339),
		UpdatedAt:       i.UpdatedAt.Format(time.RFC3339),
		User:            user,
	}
}
